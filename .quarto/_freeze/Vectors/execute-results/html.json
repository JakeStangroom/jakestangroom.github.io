{
  "hash": "62ccc0bae424678651ea7d77a5a9743e",
  "result": {
    "engine": "knitr",
    "markdown": "# Vectors {#sec-day2-vect}\n\nLet us build on the basics of *Vectors* which were covered previously. Vectors are essential for organizing and performing calculations on larger collections of data when used correctly. Below, we cover the best practice for assignment of vectors and optimal calculations using vectors.\n\n## Vector Assignment\n\nThe code chunk below exemplifies the performance benefits of avoiding unnecessary appending to vectors (or just appending in general), especially when first constructing your vector.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlen <- 10000\nstartTime <- Sys.time()\n\nstorage <- c()\nfor (i in 1:len){\n  storage <- c(storage, i)\n}\n\n(badExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.249747 secs\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(storage)\n\n\nstartTime <- Sys.time()\n\nstorage <- numeric(len)\nfor (i in 1:len){\n  storage[i] <- i\n}\n\n(goodExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.005746841 secs\n```\n\n\n:::\n:::\n\n\n\n\n## Vectorisation\n\nVectorization is the process of performing operations on entire vectors or arrays instead of using explicit loops of single scalars. It takes advantage of R's optimized internal functions, leading to faster and more efficient code execution.\n\nThere are a few benefits for vectorisation - **Speed**: Vectorized operations are significantly faster than loops. - **Conciseness**: Code is shorter and easier to read. - **Optimized Performance**: R's internal functions are written in compiled languages like *C* and *Fortran*, making them more efficient than explicit loops.\n\nThere are several base operations in R which have been extended from single scalar operations to vector operations where both the inputs and outputs are vectors. This operates in the same way as looping through the scalar input versions; however, much quicker.\n\n### Performance\n\nEven for a simple squaring function, the performance difference between vectorisation and for loops is present.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlen <- 10000\nstartTime <- Sys.time()\n\nstorage <- numeric(len)\nfor (i in 1:len){\n  storage[i] <- i^2\n}\n\n(badExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.009124041 secs\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(storage)\nstartTime <- Sys.time()\n\nstorage <- (1:len)^2\n\n(goodExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.001600027 secs\n```\n\n\n:::\n:::\n\n\n\n\n### Creating Vectorised Functions\n\nWhen one makes a function of scalar inputs, R provides a simple method to transform them into a vectorised version of the function as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(a, b){\n  return(a^b)\n}\n\nfVec <- Vectorize(f, vectorize.args = 'a')\n\n\nlen <- 1000\nstartTime <- Sys.time()\n\nstorage <- numeric(len)\nfor (i in 1:len){\n  storage[i] <- f(i, i)\n}\n\n(badExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.005957842 secs\n```\n\n\n:::\n\n```{.r .cell-code}\nrm(storage)\nstartTime <- Sys.time()\nar <- 1:len\nstorage <- fVec(ar, 3)\n\n(goodExec <- Sys.time() - startTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nTime difference of 0.002950907 secs\n```\n\n\n:::\n:::\n\n\n\n\nWhilst you should see performance benefits doing this, `Vectorize` is really just a wrapper function for some other base R functions which apply a function to a collection of elements without the same overheads seen by a `for` loop.\n\n## Vectorized Alternatives to Loops\n\n## Comparison of `apply()`, `lapply()`, and `sapply()`\n\n### `apply()`\n\n-   Used for applying functions to rows or columns of matrices and data frames.\n-   Returns a vector, matrix, or array depending on input and function used.\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_data <- matrix(1:9, nrow=3)\napply(matrix_data, 1, sum)  # Row sums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12 15 18\n```\n\n\n:::\n\n```{.r .cell-code}\napply(matrix_data, 2, sum)  # Column sums\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6 15 24\n```\n\n\n:::\n:::\n\n\n\n\n### `lapply()`\n\n-   Used for lists and returns a **list**.\n-   Applies a function to each element of a list.\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:5, b = 6:10)\nlapply(x, mean)  # Returns a list with mean of each vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$a\n[1] 3\n\n$b\n[1] 8\n```\n\n\n:::\n:::\n\n\n\n\n### `sapply()`\n\n-   Similar to `lapply()`, but tries to simplify the output to a **vector** or **matrix** when possible.\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- list(a = 1:5, b = 6:10)\nsapply(x, mean)  # Returns a named vector\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na b \n3 8 \n```\n\n\n:::\n:::\n\n\n\n\n### Key Differences\n\n| Function | Input Type | Output Type | Best For |\n|----|----|----|----|\n| `apply()` | Matrix/Data Frame | Vector/Matrix/Array | Applying functions to rows/columns |\n| `lapply()` | List | List | When output must remain a list |\n| `sapply()` | List | Vector/Matrix (if possible) | When output can be simplified |\n\n### `replicate()`\n\nAnother vectorised function is `replicate` which focuses on repeating an expression/function multiple times. This makes it very useful when you want multiple evaluations of the same or similar expression, such as in simulation tasks.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(replicate(10, sample(1:10,1,T)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  3  9 10  4  4 10 10  4  6  8\n```\n\n\n:::\n:::\n\n\n\n\n## When to Use Vectorization\n\n-   When working with large datasets to improve efficiency.\n-   When performing mathematical operations on vectors or matrices.\n-   When using functions that inherently support vector inputs.\n\n## When Not to Use Vectorization\n\n-   When operations require sequential dependencies (e.g., recursive functions).\n-   When handling complex logical flows that require explicit iteration.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}