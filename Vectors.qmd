# Vectors {#sec-day2-vect}

Let us build on the basics of *Vectors* which were covered previously. Vectors are essential for organizing and performing calculations on larger collections of data when used correctly. Below, we cover the best practice for assignment of vectors and optimal calculations using vectors.

## Vector Assignment

The code chunk below exemplifies the performance benefits of avoiding unnecessary appending to vectors (or just appending in general), especially when first constructing your vector.

```{r performance1}
len <- 10000
startTime <- Sys.time()

storage <- c()
for (i in 1:len){
  storage <- c(storage, i)
}

(badExec <- Sys.time() - startTime)
rm(storage)


startTime <- Sys.time()

storage <- numeric(len)
for (i in 1:len){
  storage[i] <- i
}

(goodExec <- Sys.time() - startTime)

```

## Vectorisation

Vectorization is the process of performing operations on entire vectors or arrays instead of using explicit loops of single scalars. It takes advantage of R's optimized internal functions, leading to faster and more efficient code execution.

There are a few benefits for vectorisation - **Speed**: Vectorized operations are significantly faster than loops. - **Conciseness**: Code is shorter and easier to read. - **Optimized Performance**: R's internal functions are written in compiled languages like *C* and *Fortran*, making them more efficient than explicit loops.

There are several base operations in R which have been extended from single scalar operations to vector operations where both the inputs and outputs are vectors. This operates in the same way as looping through the scalar input versions; however, much quicker.

### Performance

Even for a simple squaring function, the performance difference between vectorisation and for loops is present.

```{r}
len <- 10000
startTime <- Sys.time()

storage <- numeric(len)
for (i in 1:len){
  storage[i] <- i^2
}

(badExec <- Sys.time() - startTime)

rm(storage)
startTime <- Sys.time()

storage <- (1:len)^2

(goodExec <- Sys.time() - startTime)

```

### Creating Vectorised Functions

When one makes a function of scalar inputs, R provides a simple method to transform them into a vectorised version of the function as follows:

```{r}

f <- function(a, b){
  return(a^b)
}

fVec <- Vectorize(f, vectorize.args = 'a')


len <- 1000
startTime <- Sys.time()

storage <- numeric(len)
for (i in 1:len){
  storage[i] <- f(i, i)
}

(badExec <- Sys.time() - startTime)

rm(storage)
startTime <- Sys.time()
ar <- 1:len
storage <- fVec(ar, 3)

(goodExec <- Sys.time() - startTime)
```

Whilst you should see performance benefits doing this, `Vectorize` is really just a wrapper function for some other base R functions which apply a function to a collection of elements without the same overheads seen by a `for` loop.

## Vectorized Alternatives to Loops

## Comparison of `apply()`, `lapply()`, and `sapply()`

### `apply()`

-   Used for applying functions to rows or columns of matrices and data frames.
-   Returns a vector, matrix, or array depending on input and function used.

Example:

```{r}
matrix_data <- matrix(1:9, nrow=3)
apply(matrix_data, 1, sum)  # Row sums
apply(matrix_data, 2, sum)  # Column sums
```

### `lapply()`

-   Used for lists and returns a **list**.
-   Applies a function to each element of a list.

Example:

```{r}
x <- list(a = 1:5, b = 6:10)
lapply(x, mean)  # Returns a list with mean of each vector
```

### `sapply()`

-   Similar to `lapply()`, but tries to simplify the output to a **vector** or **matrix** when possible.

Example:

```{r}
x <- list(a = 1:5, b = 6:10)
sapply(x, mean)  # Returns a named vector
```

### Key Differences

| Function | Input Type | Output Type | Best For |
|----|----|----|----|
| `apply()` | Matrix/Data Frame | Vector/Matrix/Array | Applying functions to rows/columns |
| `lapply()` | List | List | When output must remain a list |
| `sapply()` | List | Vector/Matrix (if possible) | When output can be simplified |

### `replicate()`

Another vectorised function is `replicate` which focuses on repeating an expression/function multiple times. This makes it very useful when you want multiple evaluations of the same or similar expression, such as in simulation tasks.

```{r}

(replicate(10, sample(1:10,1,T)))

```

## When to Use Vectorization

-   When working with large datasets to improve efficiency.
-   When performing mathematical operations on vectors or matrices.
-   When using functions that inherently support vector inputs.

## When Not to Use Vectorization

-   When operations require sequential dependencies (e.g., recursive functions).
-   When handling complex logical flows that require explicit iteration.
